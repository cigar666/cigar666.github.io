<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pyNastran笔记 02</title>
      <link href="/2021/07/21/pyNastran%E7%AC%94%E8%AE%B0-02/"/>
      <url>/2021/07/21/pyNastran%E7%AC%94%E8%AE%B0-02/</url>
      
        <content type="html"><![CDATA[<h1 id="pyNastran笔记-02"><a href="#pyNastran笔记-02" class="headerlink" title="pyNastran笔记 02"></a>pyNastran笔记 02</h1><p><a href="https://pypi.python.org/pypi/pyNastran"><img src="https://img.shields.io/pypi/v/pynastran.svg" alt="PyPi Version" style="zoom:100%;" align='left'/></a><br></p><p>接<a href="https://cigar666.github.io/2021/07/05/pyNastran%E7%AC%94%E8%AE%B0_01/">上文</a>测试了对<code>bdf</code>卡的读写，继续测试对结果文件<code>op2</code>的读取分析。</p><h3 id="Part-2-OP2"><a href="#Part-2-OP2" class="headerlink" title="Part 2: OP2"></a>Part 2: OP2</h3><p><strong>pyNastran</strong>读取结果文件主要通过读取<code>.op2</code>文件来实现（其原因在于<code>.op2</code>格式更小，数据组织形式能更快更方便地读取，而<code>.f06</code>文件则没有上述优点）。到底有多快呢？下面是文档中的原话：</p><blockquote><p>The OP2 is preferred as it is much faster and easier to parse. How fast? You can read a 2 GB OP2 in 4 seconds, an 8 GB file in 15 seconds, and a 60 GB file in 1-2 minutes.</p></blockquote><h4 id="1-Read-amp-Write"><a href="#1-Read-amp-Write" class="headerlink" title="1. Read &amp; Write"></a>1. Read &amp; Write</h4><p>读取<code>.op2</code>文件得到基本信息并写入<code>.f06</code>文件中。</p><p>所用的模型如下（路径已做修改）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import pyNastran</span></span><br><span class="line"><span class="comment"># pkg_path = pyNastran.__path__[0]</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">pkg_path = <span class="string">&#x27;E:\\GitHub\\pyNastran\\pyNastran&#x27;</span></span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;solid_bending&#x27;</span>)</span><br><span class="line">op2_filename = os.path.join(test_path, <span class="string">&#x27;solid_bending.op2&#x27;</span>)</span><br><span class="line">f06_filename = os.path.join(test_path, <span class="string">&#x27;solid_bending_out.f06&#x27;</span>)</span><br></pre></td></tr></table></figure><p>导入<code>OP2</code>读取结果文件并打印基本信息，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyNastran.op2.op2 <span class="keyword">import</span> OP2</span><br><span class="line">model = OP2()</span><br><span class="line">model.read_op2(op2_filename)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;#&#x27;</span> * <span class="number">60</span> + <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 与DEBUG信息分隔一下</span></span><br><span class="line"><span class="built_in">print</span>(model.get_op2_stats())</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">op2_results.stress.ctetra_stress[1]</span><br><span class="line">  type=RealSolidStressArray nelements=186 nnodes=930</span><br><span class="line">  nodes_per_element=5 (including centroid)</span><br><span class="line">  eType, cid</span><br><span class="line">  data: [1, nnodes, 10] where 10=[oxx, oyy, ozz, txy, tyz, txz, omax, omid, omin, von_mises]</span><br><span class="line">  element_node.shape = (930, 2)</span><br><span class="line">  element_cid.shape = (186, 2)</span><br><span class="line">  data.shape = (1, 930, 10)</span><br><span class="line">  element name: CTETRA</span><br><span class="line">  sort1</span><br><span class="line">  lsdvmns = [1]</span><br><span class="line"></span><br><span class="line">displacements[1]</span><br><span class="line">  isubcase = 1</span><br><span class="line">  type=RealDisplacementArray nnodes=72, table_name=OUGV1</span><br><span class="line">  data: [t1, t2, t3, r1, r2, r3] shape=[1, 72, 6] dtype=float32</span><br><span class="line">  node_gridtype.shape = (72, 2)</span><br><span class="line">  sort1</span><br><span class="line">  lsdvmns = [1]</span><br><span class="line"></span><br><span class="line">spc_forces[1]</span><br><span class="line">  isubcase = 1</span><br><span class="line">  type=RealSPCForcesArray nnodes=72, table_name=OQG1</span><br><span class="line">  data: [t1, t2, t3, r1, r2, r3] shape=[1, 72, 6] dtype=float32</span><br><span class="line">  node_gridtype.shape = (72, 2)</span><br><span class="line">  sort1</span><br><span class="line">  lsdvmns = [1]</span><br></pre></td></tr></table></figure><p>通过<code>model.write_f06(f06_filename)</code>就能将结果写入对应的<code>.f06</code>文件中。</p><h4 id="2-Displacement（static"><a href="#2-Displacement（static" class="headerlink" title="2. Displacement（static)"></a>2. Displacement（static)</h4><p>这个例子将读取并计算节点的静变形<br>$$<br>\sqrt{\left(T_x^2 + T_y^2 + T_z^2\right)}<br>$$<br>路径和模型实例化代码和第1例中基本相同（稍有调整和注释），直接给出所有代码吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import pyNastran</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkg_path = pyNastran.__path__[0]</span></span><br><span class="line">pkg_path = <span class="string">&#x27;E:\\GitHub\\pyNastran\\pyNastran&#x27;</span></span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;solid_bending&#x27;</span>)</span><br><span class="line">op2_filename = os.path.join(test_path, <span class="string">&#x27;solid_bending.op2&#x27;</span>)</span><br><span class="line"><span class="comment"># f06_filename = os.path.join(test_path, &#x27;solid_bending_out.f06&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyNastran.op2.op2 <span class="keyword">import</span> OP2</span><br><span class="line">model = OP2()</span><br><span class="line">model.read_op2(op2_filename)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;#&#x27;</span> * <span class="number">60</span> + <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 与DEBUG信息分隔一下</span></span><br><span class="line"><span class="comment"># print(model.get_op2_stats())</span></span><br><span class="line"></span><br><span class="line">itime = <span class="number">0</span></span><br><span class="line">isubcase = <span class="number">1</span> <span class="comment"># 选择工况1</span></span><br><span class="line"></span><br><span class="line">disp = model.displacements[isubcase]</span><br><span class="line"><span class="comment"># 这里disp.data包含所有位移信息，</span></span><br><span class="line"><span class="comment"># 其中disp.data[itime]为itime对应时间的位移，为一个六列的二维阵列，</span></span><br><span class="line"><span class="comment"># 每列对应：tx, ty, tz, rx, ry, rz. (更具体的可见get_op2_stats方法得到的结果)</span></span><br><span class="line">txyz = disp.data[itime, :, :<span class="number">3</span>] <span class="comment"># 取前三列就行了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line">total_xyz = norm(txyz, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 这里不用norm也行</span></span><br><span class="line"><span class="comment"># total_xyz = np.sqrt(sum(txyz[:, i] ** 2 for i in range(3)))</span></span><br><span class="line"><span class="comment"># total_xyz = np.sqrt(txyz[:, 0]**2+txyz[:, 1]**2+txyz[:, 2]**2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将变形信息打印出来</span></span><br><span class="line">msg = <span class="string">&#x27;nid, gridtype, tx, ty, tz, txyz&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"><span class="keyword">for</span> (nid, grid_type), txyz, total_xyzi <span class="keyword">in</span> <span class="built_in">zip</span>(disp.node_gridtype, txyz, total_xyz):</span><br><span class="line">    msg = <span class="string">&#x27;%s, %s, %s, %s, %s, %s&#x27;</span> % (nid, grid_type, txyz[<span class="number">0</span>], txyz[<span class="number">1</span>], txyz[<span class="number">2</span>], total_xyzi)</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><h4 id="3-Example-3-6"><a href="#3-Example-3-6" class="headerlink" title="3. Example 3~6"></a>3. Example 3~6</h4><p>后面的 Example 3, 4, 5, 6 分别针对瞬态（特征值）、体元、各向同性板、复材板的<code>op2</code>文件进行读取。其中用到的东西大体上和[这小结](####2. Displacement（static)的方法差不多，就不逐一展开了。</p><p>注：docs中此处内容编排貌似有些错误，标题重复，内容和实际不匹配，但仔细测了代码发现问题不大，仅发现<code> stress.is_fiber_distance()</code>的布尔值有些问题（删除对应代码后少了个异常判断，并不影响其余），后续可仔细看看具体是哪儿出问题</p><p>读取到的信息可预先通过<code>get_op2_stats</code>方法查询，再决定后续对那些需要的数据进行读取，以及如何进行处理。</p><p>比如，对于 <strong>Example 5</strong> 和 <strong>Example 6</strong> 都是用了同一个文件，里面有各向同性材料也有复材。通过如下代码，查看读取到的相关信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">pkg_path = <span class="string">&#x27;E:\\GitHub\\pyNastran\\pyNastran&#x27;</span></span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;sol_101_elements&#x27;</span>)</span><br><span class="line">op2_filename = os.path.join(test_path, <span class="string">&#x27;static_solid_shell_bar.op2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyNastran.op2.op2 <span class="keyword">import</span> OP2</span><br><span class="line">model = OP2()</span><br><span class="line">model.read_op2(op2_filename)</span><br><span class="line"><span class="built_in">print</span>(model.get_op2_stats())</span><br></pre></td></tr></table></figure><p>运行后会发现一大堆信息。比如，如下这段信息就作为 <strong>Example 5</strong> 中读取（所有<strong>CQUAD4单元</strong>对应）最大主应力等信息提供了参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cquad4_stress[1]</span><br><span class="line">  type=RealPlateStressArray nelements=2 nnodes_per_element=5 nlayers=2 ntotal=20</span><br><span class="line">  data: [1, ntotal, 8] where 8=[fiber_distance, oxx, oyy, txy, angle, omax, omin, von_mises]</span><br><span class="line">  element_node.shape = (20, 2)</span><br><span class="line">  data.shape=(1, 20, 8)</span><br><span class="line">  element type: CQUAD144</span><br><span class="line">  s_code: 1</span><br><span class="line">  sort1</span><br><span class="line">  lsdvmns = [1]</span><br></pre></td></tr></table></figure><p>所以，所有<strong>CQUAD4单元</strong>对应最大主应力可以由如下代码给出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [fiber_distance, oxx, oyy, txy, angle, omax, omin, von_mises]</span></span><br><span class="line">itime = <span class="number">0</span></span><br><span class="line">isubcase = <span class="number">1</span></span><br><span class="line">stress = model.cquad4_stress[isubcase]</span><br><span class="line">maxp = stress.data[itime, :, <span class="number">5</span>] <span class="comment"># 对应第六列</span></span><br></pre></td></tr></table></figure><p>同样的，在 <strong>Example 6</strong> 中读取<strong>CTRIA3单元</strong>的复材对应的信息时，可参考下面这段信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctria3_composite_stress[1]</span><br><span class="line">  type=RealCompositePlateStressArray nelements=4 ntotal=18</span><br><span class="line">  data: [1, ntotal, 9] where 9=[o11, o22, t12, t1z, t2z, angle, major, minor, max_shear]</span><br><span class="line">  element_layer.shape = (18, 2)</span><br><span class="line">  data.shape = (1, 18, 9)</span><br><span class="line">  element type: TRIA3-nonlinear</span><br><span class="line">  sort1</span><br><span class="line">  lsdvmns = [1]</span><br></pre></td></tr></table></figure><p>后续读取最大主应力的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [o11, o22, t12, t1z, t2z, angle, major, minor, max_shear]</span></span><br><span class="line">itime = <span class="number">0</span></span><br><span class="line">isubcase = <span class="number">1</span></span><br><span class="line">stress = model.ctria3_composite_stress[isubcase]</span><br><span class="line">eids = stress.element_layer[:, <span class="number">0</span>]</span><br><span class="line">layers = stress.element_layer[:, <span class="number">1</span>]</span><br><span class="line">maxp = stress.data[itime, :, <span class="number">6</span>] <span class="comment"># 此处docs中的例子写的是stress.data[itime, :, 5]，但第五列明显输出的是铺层角度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (eid, layer, maxpi) <span class="keyword">in</span> <span class="built_in">zip</span>(eids, layers, maxp):</span><br><span class="line">    <span class="built_in">print</span>(eid, <span class="string">&#x27;CEN/4&#x27;</span>, layer, maxpi)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">18 CEN/4 1 2628.2844</span><br><span class="line">18 CEN/4 2 2618.0947</span><br><span class="line">18 CEN/4 3 2601.1123</span><br><span class="line">18 CEN/4 4 2577.3376</span><br><span class="line">19 CEN/4 1 2103.5042</span><br><span class="line">19 CEN/4 2 2100.923</span><br><span class="line">19 CEN/4 3 2096.6226</span><br><span class="line">19 CEN/4 4 2090.605</span><br><span class="line">20 CEN/4 1 1875.7615</span><br><span class="line">20 CEN/4 2 1878.8408</span><br><span class="line">20 CEN/4 3 1883.9808</span><br><span class="line">20 CEN/4 4 1891.193</span><br><span class="line">20 CEN/4 5 1900.494</span><br><span class="line">21 CEN/4 1 1592.4011</span><br><span class="line">21 CEN/4 2 1590.0106</span><br><span class="line">21 CEN/4 3 1586.0325</span><br><span class="line">21 CEN/4 4 1580.4755</span><br><span class="line">21 CEN/4 5 1573.3535</span><br></pre></td></tr></table></figure><hr><p>测试的东西不算很多，基本的读取操作都很雷同。具体使用的时候根据自己的需求结合<code>get_op2_stats</code>方法的提示信息应该就能得到想要的结果。</p><p>如果仅仅是读取结果，然后简单地处理和打印输出，可能还不如<code>f06</code>文件来的方便。所以，有了读取到的结果，如何能更好发挥这些结果的价值，可能是之后的使用过程中需要去挖掘的。就目前而言，结合实际工作中遇到的一些场景，我对<strong>pyNastran</strong>能用来干啥大概有一些想法，之后可以试试看。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nastran </tag>
            
            <tag> python </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyNastran笔记 01</title>
      <link href="/2021/07/05/pyNastran%E7%AC%94%E8%AE%B0_01/"/>
      <url>/2021/07/05/pyNastran%E7%AC%94%E8%AE%B0_01/</url>
      
        <content type="html"><![CDATA[<h1 id="pyNastran笔记-01"><a href="#pyNastran笔记-01" class="headerlink" title="pyNastran笔记 01"></a>pyNastran笔记 01</h1><p><a href="https://pypi.python.org/pypi/pyNastran"><img src="https://img.shields.io/pypi/v/pynastran.svg" alt="PyPi Version" style="zoom:100%;" align='left'/></a><br></p><p>在工作之后，接触<strong>Patran</strong>+<strong>Nastran</strong>已经好几个月了，也算了解了其基本的用法。对于<strong>Patran</strong>+<strong>Nastran</strong>更深入的学习，比如求解卡的相关知识（忘了就去查<code>qrg.pdf</code>）、PCL相关知识以及其他一些进阶的操作，也在平时的使用中逐渐掌握。前不久碰巧淘到<a href="https://pypi.python.org/pypi/pyNastran"><strong>pyNastran</strong></a>这个python库（暂不做详细介绍了），能对<strong>Nastran</strong>的求解文件进行读取和编辑，试了下发现还蛮香的。所以，在这里随手记录下一些笔记吧。主要写给自己看，因此写得就稍微随意点，相关代码的写法也许也不一定很棒，期待能在之后不断改进:-)</p><blockquote><p>Nastran BDF/F06/OP2/OP4 File reader/editor/writer/viewer.</p><p>-the description of <strong>pyNastran</strong> on pypi</p></blockquote><p>相关链接：</p><ul><li><a href="https://github.com/SteveDoyle2/pyNastran">github代码</a></li><li><a href="http://groups.google.com/group/pynastran-discuss">Discussion forum</a></li><li><a href="http://groups.google.com/group/pynastran-dev">Developer forum</a> </li><li><a href="https://pynastran-git.readthedocs.io/en/1.3/">Docs</a></li></ul><h2 id="Part-1-BDF"><a href="#Part-1-BDF" class="headerlink" title="Part 1: BDF"></a>Part 1: BDF</h2><p>对<a href="https://pynastran-git.readthedocs.io/en/1.3/">Docs</a>的Quick Start部分进行了测试和整理，先把对<code>bdf</code>文件操作这部分写出来吧。</p><h3 id="1-Read-Write"><a href="#1-Read-Write" class="headerlink" title="1.Read/Write"></a>1.Read/Write</h3><p>按照<strong>Example 1: Read/Write</strong>中代码所示，并合并调整后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyNastran</span><br><span class="line"><span class="keyword">from</span> pyNastran.bdf.bdf <span class="keyword">import</span> BDF</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">pkg_path = pyNastran.__path__[<span class="number">0</span>]</span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;solid_bending&#x27;</span>)</span><br><span class="line">bdf_filename = os.path.join(test_path, <span class="string">&#x27;solid_bending.bdf&#x27;</span>)</span><br><span class="line">model = BDF()</span><br><span class="line">model.read_bdf(bdf_filename)</span><br></pre></td></tr></table></figure><p>但由于使用pip安装的<strong>pyNastran</strong>并没有对应的model文件，<del>考虑将<strong>GitHub</strong>中对应的<strong>pyNastran</strong>中的<strong>model</strong>文件夹复制到<strong>site-packages</strong>下</del>（想想还是算了吧，尽量还是别去动<strong>site-packages</strong>下的东西）。</p><p>将<code>pkg_path</code>定位到<strong>Github</strong>中克隆下来的<strong>pyNastran</strong>下，然后就能正常读入<code>.bdf</code>文件了。改后代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyNastran.bdf.bdf <span class="keyword">import</span> BDF</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkg_path = pyNastran.__path__[0]</span></span><br><span class="line">pkg_path = <span class="string">&#x27;E:\\GitHub\\pyNastran\\pyNastran&#x27;</span></span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;solid_bending&#x27;</span>)</span><br><span class="line">bdf_filename = os.path.join(test_path, <span class="string">&#x27;solid_bending.bdf&#x27;</span>)</span><br><span class="line">model = BDF()</span><br><span class="line">model.read_bdf(bdf_filename)</span><br></pre></td></tr></table></figure><p>成功读入<code>.bdf</code>文件后，控制台返回如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEBUG:   bdf.py:995                   ---starting BDF.read_bdf of E:\GitHub\pyNastran\pyNastran\..\models\solid_bending\solid_bending.bdf---</span><br><span class="line">DEBUG:   pybdf.py:556                 opening &#x27;E:\\GitHub\\pyNastran\\models\\solid_bending\\solid_bending.bdf&#x27;</span><br><span class="line">DEBUG:   cross_reference.py:151       Cross Referencing...</span><br><span class="line">DEBUG:   bdf.py:1043                  ---finished BDF.read_bdf of E:\GitHub\pyNastran\pyNastran\..\models\solid_bending\solid_bending.bdf---</span><br><span class="line">[Finished in 0.8s]</span><br></pre></td></tr></table></figure><p>继续试一下打印出模型信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(model.get_bdf_stats())</span><br><span class="line">---BDF Statistics---</span><br><span class="line">SOL <span class="number">101</span></span><br><span class="line">bdf.load_combinations[<span class="number">2</span>]</span><br><span class="line">  LOAD:    <span class="number">1</span></span><br><span class="line">bdf.loads[<span class="number">1</span>]</span><br><span class="line">  FORCE:   <span class="number">23</span></span><br><span class="line">bdf.spcadds[<span class="number">2</span>]</span><br><span class="line">  SPCADD:  <span class="number">1</span></span><br><span class="line">bdf.spcs[<span class="number">1</span>]</span><br><span class="line">  SPC1:    <span class="number">1</span></span><br><span class="line">bdf.spcs[<span class="number">3</span>]</span><br><span class="line">  SPC1:    <span class="number">1</span></span><br><span class="line">bdf.params</span><br><span class="line">  PARAM    : <span class="number">2</span></span><br><span class="line">bdf.nodes</span><br><span class="line">  GRID     : <span class="number">72</span></span><br><span class="line">bdf.elements</span><br><span class="line">  CTETRA   : <span class="number">186</span></span><br><span class="line">bdf.properties</span><br><span class="line">  PSOLID   : <span class="number">1</span></span><br><span class="line">bdf.materials</span><br><span class="line">  MAT1     : <span class="number">1</span></span><br></pre></td></tr></table></figure><p>写文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bdf_filename_out = os.path.join(test_path, <span class="string">&#x27;solid_bending_out.bdf&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.write_bdf(bdf_filename_out)</span><br></pre></td></tr></table></figure><p>运行后会在<code>test_path</code>对应的路径下生成<code>solid_bending_out.bdf</code>文件。</p><p><strong>时间关系，后面这部分之后有空再试。</strong></p><blockquote><p>looking at the output</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(file_slice(bdf_filename_out, <span class="number">94</span>, <span class="number">100</span>))</span><br><span class="line">GRID          <span class="number">71</span>         <span class="number">.500008</span> <span class="number">1.61116</span>      <span class="number">3.</span></span><br><span class="line">GRID          <span class="number">72</span>         <span class="number">.500015</span> <span class="number">1.00001</span>      <span class="number">3.</span></span><br><span class="line">$ELEMENTS_WITH_PROPERTIES</span><br><span class="line">PSOLID         <span class="number">1</span>       <span class="number">1</span></span><br><span class="line">CTETRA         <span class="number">1</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">13</span>      <span class="number">67</span>      <span class="number">33</span></span><br><span class="line">CTETRA         <span class="number">2</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">7</span>      <span class="number">62</span>      <span class="number">59</span></span><br></pre></td></tr></table></figure><p>write the file with large field format; double precision</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bdf_filename_out2 = os.path.join(test_path, <span class="string">&#x27;solid_bending_out2.bdf&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.write_bdf(bdf_filename_out2, size=<span class="number">16</span>, is_double=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(file_slice(bdf_filename_out2, <span class="number">166</span>, <span class="number">175</span>))</span><br><span class="line">GRID*                 <span class="number">71</span>                         <span class="number">.500008</span>         <span class="number">1.61116</span></span><br><span class="line">*                     <span class="number">3.</span></span><br><span class="line">GRID*                 <span class="number">72</span>                         <span class="number">.500015</span>         <span class="number">1.00001</span></span><br><span class="line">*                     <span class="number">3.</span></span><br><span class="line">$ELEMENTS_WITH_PROPERTIES</span><br><span class="line">PSOLID         <span class="number">1</span>       <span class="number">1</span></span><br><span class="line">CTETRA         <span class="number">1</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">13</span>      <span class="number">67</span>      <span class="number">33</span></span><br><span class="line">CTETRA         <span class="number">2</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">7</span>      <span class="number">62</span>      <span class="number">59</span></span><br><span class="line">CTETRA         <span class="number">3</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">45</span>      <span class="number">58</span>      <span class="number">66</span></span><br></pre></td></tr></table></figure><p>write the file with large field format; double precision</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bdf_filename_out3 = os.path.join(test_path, <span class="string">&#x27;solid_bending_out3.bdf&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.write_bdf(bdf_filename_out3, size=<span class="number">16</span>, is_double=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(file_slice(bdf_filename_out3, <span class="number">166</span>, <span class="number">175</span>))</span><br><span class="line">GRID*                 <span class="number">71</span>                <span class="number">5.0000800000</span>D-<span class="number">011.6111600000</span>D+<span class="number">00</span></span><br><span class="line">*       <span class="number">3.0000000000</span>D+<span class="number">00</span></span><br><span class="line">GRID*                 <span class="number">72</span>                <span class="number">5.0001500000</span>D-<span class="number">011.0000100000</span>D+<span class="number">00</span></span><br><span class="line">*       <span class="number">3.0000000000</span>D+<span class="number">00</span></span><br><span class="line">$ELEMENTS_WITH_PROPERTIES</span><br><span class="line">PSOLID         <span class="number">1</span>       <span class="number">1</span></span><br><span class="line">CTETRA         <span class="number">1</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">13</span>      <span class="number">67</span>      <span class="number">33</span></span><br><span class="line">CTETRA         <span class="number">2</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">7</span>      <span class="number">62</span>      <span class="number">59</span></span><br><span class="line">CTETRA         <span class="number">3</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">45</span>      <span class="number">58</span>      <span class="number">66</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-Printing-Nodes"><a href="#2-Printing-Nodes" class="headerlink" title="2.Printing Nodes"></a>2.Printing Nodes</h3><p>把示例中的代码整合到一起，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyNastran.bdf.bdf <span class="keyword">import</span> BDF</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkg_path = pyNastran.__path__[0]</span></span><br><span class="line">pkg_path = <span class="string">&#x27;E:\\GitHub\\pyNastran\\pyNastran&#x27;</span></span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;solid_bending&#x27;</span>)</span><br><span class="line">bdf_filename = os.path.join(test_path, <span class="string">&#x27;solid_bending.bdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = BDF()</span><br><span class="line">model.read_bdf(bdf_filename, xref=<span class="literal">True</span>)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;junk.out&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># 这个模型后面会反复用到。在这行之前的代码都一样，后面部分对应各个例子中的对应代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for nid,node in sorted(model.nodes.items()):</span></span><br><span class="line"><span class="comment">#     f.write(node.write_card(size=8, is_double=False))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if model.gridSet: # 这儿会报错，提示&#x27;BDF&#x27; object has no attribute &#x27;gridSet&#x27;</span></span><br><span class="line"><span class="comment">#     f.write(model.gridSet.write_card(size=8, is_double=False))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if model.spoints:</span></span><br><span class="line"><span class="comment">#     f.write(model.spoints.write_card(size=8, is_double=False))</span></span><br><span class="line"><span class="comment"># for cid,coord in sorted(model.coords.items()):</span></span><br><span class="line"><span class="comment">#     if cid != 0:  # if CID=0 is the global frame, skip it</span></span><br><span class="line"><span class="comment">#         f.write(coord)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释部分的功能等价于以下两句内置方法</span></span><br><span class="line">model._write_nodes(f)</span><br><span class="line">model._write_coords(f)</span><br></pre></td></tr></table></figure><p>运行后会在对应目录生成名为**’junk.out’**的文件，里面为节点的信息。</p><h3 id="3-Printing-Elements-Properties"><a href="#3-Printing-Elements-Properties" class="headerlink" title="3.Printing Elements/Properties"></a>3.Printing Elements/Properties</h3><p>接上文<strong>Printing Nodes</strong>中的代码，继续打印<strong>Elements</strong>和<strong>Properties</strong>。</p><p>文档中使用了三种方式来实现：</p><ul><li><p><strong>Method 1</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> eid, element <span class="keyword">in</span> <span class="built_in">sorted</span>(model.elements.items()):</span><br><span class="line">    f.write(element.write_card(size=<span class="number">8</span>, is_double=<span class="literal">False</span>))</span><br><span class="line"><span class="keyword">for</span> pid, prop <span class="keyword">in</span> <span class="built_in">sorted</span>(model.properties.items()):</span><br><span class="line">    f.write(prop.write_card(size=<span class="number">8</span>, is_double=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>Method 2</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model._write_elements_properties(f) </span><br><span class="line"><span class="comment"># 试了下会报错：&#x27;BDF&#x27; object has no attribute &#x27;_write_elements_properties&#x27;</span></span><br><span class="line"><span class="comment"># 查了下确实没这个方法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Method 3:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model._write_elements(f)</span><br><span class="line">model._write_properties(f)</span><br><span class="line"><span class="comment"># 这段能正常运行，结果和&#x27;Method 1&#x27;相同</span></span><br></pre></td></tr></table></figure></li></ul><p>逐一尝试之后<strong>Method 2</strong>不能正常运行。</p><h3 id="4-Get-Element-ID-amp-Type"><a href="#4-Get-Element-ID-amp-Type" class="headerlink" title="4.Get Element ID &amp; Type"></a>4.Get Element ID &amp; Type</h3><p>同样是用<strong>Printing Nodes</strong>中读入的模型继续操作。文档中使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> eid,element <span class="keyword">in</span> <span class="built_in">sorted</span>(model.elements.items()):</span><br><span class="line">    msg = <span class="string">&#x27;eid=%s type=%s\n&#x27;</span> %(eid, element.<span class="built_in">type</span>)</span><br><span class="line">f.write(msg)</span><br></pre></td></tr></table></figure><p>最后只输出了最大<strong>EID</strong>和对应的单元类型，看不出有啥实际用处。自己稍微再自行测试一下。</p><p><code>model.elements</code>是一个字典，<code>key</code>和<code>value</code>分别为单元的<strong>EID</strong>和其余内容，其内容如下所示（中间的内容我手动省略了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">3</span>]: model.elements</span><br><span class="line">Out[<span class="number">3</span>]: </span><br><span class="line">&#123;<span class="number">1</span>: CTETRA         <span class="number">1</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">13</span>      <span class="number">67</span>      <span class="number">33</span>,</span><br><span class="line"> <span class="number">2</span>: CTETRA         <span class="number">2</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">7</span>      <span class="number">62</span>      <span class="number">59</span>,</span><br><span class="line"> <span class="number">3</span>: CTETRA         <span class="number">3</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">45</span>      <span class="number">58</span>      <span class="number">66</span>,</span><br><span class="line"> <span class="number">4</span>: CTETRA         <span class="number">4</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">7</span>      <span class="number">67</span>      <span class="number">13</span>,</span><br><span class="line"> <span class="number">5</span>: CTETRA         <span class="number">5</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">58</span>      <span class="number">45</span>      <span class="number">59</span>,</span><br><span class="line"><span class="meta">... </span>...</span><br><span class="line"> <span class="number">182</span>: CTETRA       <span class="number">182</span>       <span class="number">1</span>      <span class="number">18</span>      <span class="number">68</span>      <span class="number">21</span>      <span class="number">23</span>,</span><br><span class="line"> <span class="number">183</span>: CTETRA       <span class="number">183</span>       <span class="number">1</span>      <span class="number">10</span>      <span class="number">11</span>       <span class="number">3</span>      <span class="number">14</span>,</span><br><span class="line"> <span class="number">184</span>: CTETRA       <span class="number">184</span>       <span class="number">1</span>       <span class="number">3</span>      <span class="number">22</span>      <span class="number">11</span>      <span class="number">18</span>,</span><br><span class="line"> <span class="number">185</span>: CTETRA       <span class="number">185</span>       <span class="number">1</span>      <span class="number">54</span>      <span class="number">39</span>      <span class="number">64</span>      <span class="number">71</span>,</span><br><span class="line"> <span class="number">186</span>: CTETRA       <span class="number">186</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">62</span>       <span class="number">4</span>      <span class="number">58</span>&#125;</span><br></pre></td></tr></table></figure><p>所以，可以通过输入对应的<strong>EID</strong>查询对应的单元信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">4</span>]: model.elements[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">4</span>]: CTETRA         <span class="number">1</span>       <span class="number">1</span>       <span class="number">8</span>      <span class="number">13</span>      <span class="number">67</span>      <span class="number">33</span></span><br></pre></td></tr></table></figure><p>更详细的其他信息的查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">5</span>]: model.elements[<span class="number">1</span>].eid</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">1</span></span><br><span class="line">In[<span class="number">6</span>]: model.elements[<span class="number">1</span>].<span class="built_in">type</span></span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;CTETRA&#x27;</span></span><br><span class="line">In[<span class="number">7</span>]: model.elements[<span class="number">1</span>].pid</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">1</span></span><br><span class="line">In[<span class="number">8</span>]: model.elements[<span class="number">1</span>].node_ids</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="number">8</span>, <span class="number">13</span>, <span class="number">67</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure><h3 id="5-Get-Elements-by-Node-ID"><a href="#5-Get-Elements-by-Node-ID" class="headerlink" title="5.Get Elements by Node ID"></a>5.Get Elements by Node ID</h3><p>通过<code>.get_node_id_to_element_ids_map()</code>方法可以知道如何得到包含某个节点的所有单元（暂不支持<strong>0d/1d</strong>单元）。</p><p>如要得到<strong>ID</strong>为55的节点对应的单元，可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nid_to_eids_map = model.get_node_id_to_element_ids_map()</span><br><span class="line">eids = nid_to_eids_map[<span class="number">55</span>]</span><br></pre></td></tr></table></figure><p>经过进一步测试，通过<code>.get_node_id_to_element_ids_map()</code>方法得到的就是所有以节点<strong>ID</strong>为<code>key</code>的字典，其对应的值为该节点对应的<strong>EID</strong>。利用这些<strong>EID</strong>可以进一步得到对应的单元，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elements = []</span><br><span class="line"><span class="keyword">for</span> eid <span class="keyword">in</span> eids:</span><br><span class="line">    elements.append(model.Element(eid))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;eids = %s&quot;</span> % eids)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;elements =\n %s&quot;</span> % elements)</span><br></pre></td></tr></table></figure><p>运行后输出的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eids = [10, 23, 104, 105, 106, 111, 135, 143, 161, 170, 177, 180]</span><br><span class="line">elements =</span><br><span class="line"> [CTETRA        10       1       7       5      62      55</span><br><span class="line">, CTETRA        23       1       7      55       6      72</span><br><span class="line">, CTETRA       104       1       7       6      55      56</span><br><span class="line">, CTETRA       105       1       6      72      55      63</span><br><span class="line">, CTETRA       106       1       6      56      63      55</span><br><span class="line">, CTETRA       111       1      55      54      64      72</span><br><span class="line">, CTETRA       135       1       7      55      62      59</span><br><span class="line">, CTETRA       143       1       7      56      55      59</span><br><span class="line">, CTETRA       161       1       5      72      54      55</span><br><span class="line">, CTETRA       170       1      55      72      64      63</span><br><span class="line">, CTETRA       177       1       7      72       5      55</span><br><span class="line">, CTETRA       180       1       5      55      54      62</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="6-Get-Elements-by-Property-ID"><a href="#6-Get-Elements-by-Property-ID" class="headerlink" title="6.Get Elements by Property ID"></a>6.Get Elements by Property ID</h3><p>和<code>.get_node_id_to_element_ids_map()</code>类似，通过<code>.get_property_id_to_element_ids_map()</code>方法可得到一个以<strong>PID</strong>为键，和对应的所有<strong>EID</strong>为值构成的字典，可用和上文类似的方法获取对应<strong>PID</strong>的所有<strong>EID</strong>或所有对应的单元。</p><p>了解了这点，为了节约时间直接应用文档中的对应内容：</p><blockquote><p>Creating a List of Elements based on a Property ID</p><p>assume pid=1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pid_to_eids_map = model.get_property_id_to_element_ids_map()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eids4  = pid_to_eids_map[<span class="number">4</span>] <span class="comment"># PSHELL</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;eids4 = %s&quot;</span> % eids4)</span><br><span class="line">eids4 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure><p>convert to elements instead of element IDs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>elements4 = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> eid <span class="keyword">in</span> eids4:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    elements4.append(model.Element(eid))</span><br></pre></td></tr></table></figure><p>just to verify</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>elem = model.elements[eids4[<span class="number">0</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(elem.pid)</span><br><span class="line">PSHELL         <span class="number">4</span>       <span class="number">1</span>     <span class="number">.25</span>       <span class="number">1</span>               <span class="number">1</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="7-Get-Elements-by-Material-ID"><a href="#7-Get-Elements-by-Material-ID" class="headerlink" title="7.Get Elements by Material ID"></a>7.Get Elements by Material ID</h3><p>和前面第5、6小节的思路完全一样，但此处通过<code>.get_material_id_to_property_ids_map()</code>方法获取得到的字典其键值分别为material的id和对应的所有property的id。因此先用<code>.get_material_id_to_property_ids_map()</code>方法找到<strong>PID</strong>，再通过<strong>PID</strong>找对应的<strong>EID</strong>或单元（同第6小节）。</p><p>这一小节所用模型和第6小节相同，和之前小节的模型文件不同。完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyNastran</span><br><span class="line"><span class="keyword">from</span> pyNastran.bdf.bdf <span class="keyword">import</span> BDF</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># pkg_path = pyNastran.__path__[0]</span></span><br><span class="line">pkg_path = <span class="string">&#x27;E:\\GitHub\\pyNastran\\pyNastran&#x27;</span></span><br><span class="line">test_path = os.path.join(pkg_path, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;models&#x27;</span>, <span class="string">&#x27;sol_101_elements&#x27;</span>) </span><br><span class="line">bdf_filename = os.path.join(test_path, <span class="string">&#x27;static_solid_shell_bar.bdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = BDF()</span><br><span class="line">model.read_bdf(bdf_filename, xref=<span class="literal">True</span>)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;junk.out&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pid_to_eids_map = model.get_property_id_to_element_ids_map()</span><br><span class="line">mid_to_pids_map = model.get_material_id_to_property_ids_map()</span><br><span class="line">pids1 = mid_to_pids_map[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pids1 = %s&#x27;</span> % pids1)</span><br><span class="line"></span><br><span class="line">eids = []</span><br><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> pids1:</span><br><span class="line">    eids += pid_to_eids_map[pid]</span><br><span class="line">elements = []</span><br><span class="line"><span class="keyword">for</span> eid <span class="keyword">in</span> eids:</span><br><span class="line">    element = model.Element(eid)</span><br><span class="line">    elements.append(element)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(element).rstrip())</span><br></pre></td></tr></table></figure><p>运行结果如下（和文档的结果略有差异，可能是因为模型文件或代码的更新情况不一致）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pids1 = [5, 1, 2, 3, 4, 4, 4, 6, 7]</span><br><span class="line">CBEAM         12       5      18      22      0.      1.      0.</span><br><span class="line">CBAR          13       1      19      23      0.      1.      0.</span><br><span class="line">$ Direct Text Input for Bulk Data</span><br><span class="line">$ Pset: &quot;shell&quot; will be imported as: &quot;pshell.1&quot;</span><br><span class="line">$ INCLUDE processed:  E:\GitHub\pyNastran\models\sol_101_elements\geom.inc</span><br><span class="line">CHEXA          1       2       2       3       4       1       8       5</span><br><span class="line">               6       7</span><br><span class="line">CPENTA         2       2       6       8       5      10      11       9</span><br><span class="line">CPENTA         3       2       6       7       8      10      12      11</span><br><span class="line">CTETRA         4       2      10      11       9      13</span><br><span class="line">CTETRA         5       2      10      12      11      13</span><br><span class="line">CROD          14       3      20      24</span><br><span class="line">CROD          15       3      21      25</span><br><span class="line">$ pshells</span><br><span class="line">CQUAD4         6       4       4       1      14      15</span><br><span class="line">CQUAD4         7       4       3       2      17      16</span><br><span class="line">CTRIA3         8       4       4       3      16</span><br><span class="line">CTRIA3         9       4      16      15       4</span><br><span class="line">CTRIA3        10       4       1       2      17</span><br><span class="line">CTRIA3        11       4      17      14       1</span><br><span class="line">$ pshells</span><br><span class="line">CQUAD4         6       4       4       1      14      15</span><br><span class="line">CQUAD4         7       4       3       2      17      16</span><br><span class="line">CTRIA3         8       4       4       3      16</span><br><span class="line">CTRIA3         9       4      16      15       4</span><br><span class="line">CTRIA3        10       4       1       2      17</span><br><span class="line">CTRIA3        11       4      17      14       1</span><br><span class="line">$ pshells</span><br><span class="line">CQUAD4         6       4       4       1      14      15</span><br><span class="line">CQUAD4         7       4       3       2      17      16</span><br><span class="line">CTRIA3         8       4       4       3      16</span><br><span class="line">CTRIA3         9       4      16      15       4</span><br><span class="line">CTRIA3        10       4       1       2      17</span><br><span class="line">CTRIA3        11       4      17      14       1</span><br><span class="line">$ pcomps</span><br><span class="line">CQUAD4        16       6      14      15      19      18</span><br><span class="line">CTRIA3        18       6      18      14      17</span><br><span class="line">CTRIA3        19       6      18      17      21</span><br><span class="line">CQUAD4        17       7      17      16      20      21</span><br><span class="line">CTRIA3        20       7      19      15      16</span><br><span class="line">CTRIA3        21       7      19      16      20</span><br></pre></td></tr></table></figure><hr><p>先写到这儿吧，有空慢慢测。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nastran </tag>
            
            <tag> python </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
